<!doctype html>
<html>
<head>
  <base target="_top">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Commodity Price Tracker</title>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b1020;
      --card:rgba(255,255,255,.06);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.70);
      --line:rgba(255,255,255,.12);
      --accent:#7dd3fc;
      --accent2:#c4b5fd;
      --good:#34d399;
      --bad:#fb7185;
      --warn:#fbbf24;
    }
    body{
      margin:0;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      background: radial-gradient(1100px 700px at 15% 10%, rgba(125,211,252,.18), transparent 55%),
                  radial-gradient(900px 650px at 85% 15%, rgba(196,181,253,.18), transparent 55%),
                  var(--bg);
      color:var(--text);
    }
    .wrap{
      max-width:1100px;
      margin:0 auto;
      padding:18px;
      box-sizing:border-box;
    }
    .topbar{
      display:flex;
      gap:12px;
      align-items:flex-end;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-bottom:14px;
    }
    .title{ font-size:20px; font-weight:800; letter-spacing:.2px; }
    .sub{ font-size:12px; color:var(--muted); margin-top:6px; line-height:1.35; }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .toggle-group{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      align-items:center;
    }
    .toggle-btn{
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      padding:6px 12px;
      font-weight:800;
      font-size:11px;
      letter-spacing:.4px;
      text-transform:uppercase;
      background: rgba(0,0,0,.25);
      color:var(--muted);
      cursor:pointer;
    }
    .toggle-btn.active{
      color:var(--text);
      border-color: rgba(125,211,252,.6);
      background: linear-gradient(135deg, rgba(125,211,252,0.25), rgba(196,181,253,0.22));
    }
    .btn{
      background: linear-gradient(135deg, rgba(125,211,252,0.28), rgba(196,181,253,0.22));
      border: 1px solid rgba(255,255,255,0.14);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 700;
    }
    .btn:disabled{ opacity:.6; cursor:not-allowed; }
    .btn.secondary{
      background: rgba(0,0,0,0.2);
      border: 1px solid rgba(255,255,255,0.25);
    }
    .admin-controls{
      display:none;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .admin-controls.is-visible{
      display:flex;
    }

    select{
      background: rgba(0,0,0,0.22);
      border: 1px solid rgba(255,255,255,0.14);
      color: var(--text);
      padding: 9px 10px;
      border-radius: 12px;
      outline: none;
      font-weight: 600;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      background: var(--card);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.28);
      overflow:hidden;
    }
    .card h3{
      margin:0 0 10px;
      font-size:13px;
      color:var(--muted);
      font-weight:800;
      letter-spacing:.35px;
      text-transform:uppercase;
    }

    .items{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 700px){
      .items{ grid-template-columns: 1fr; }
    }
    .item{
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:10px;
      cursor:pointer;
      background: rgba(0,0,0,.10);
      transition: transform .08s ease, border-color .08s ease;
    }
    .item:hover{ transform: translateY(-1px); border-color: rgba(125,211,252,.35); }
    .item.active{ border-color: rgba(196,181,253,.55); }
    .item .name{ font-weight:800; font-size:14px; display:flex; gap:8px; align-items:center; }
    .badge{
      font-size:11px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      color:rgba(255,255,255,.85);
      background:rgba(0,0,0,.18);
      line-height:1.6;
      white-space:nowrap;
    }
    .badge.stale{
      border-color: rgba(251,191,36,.55);
      color: rgba(251,191,36,.98);
    }
    .item .meta{ margin-top:6px; color:var(--muted); font-size:12px; display:flex; gap:10px; flex-wrap:wrap; }
    .source-link{
      color: var(--accent);
      font-weight: 700;
      text-decoration: none;
    }
    .source-link:hover{ text-decoration: underline; }

    .kpis{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .kpi{
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:10px;
      background: rgba(0,0,0,.10);
    }
    .kpi .label{ font-size:12px; color:var(--muted); }
    .kpi .val{ font-size:18px; font-weight:900; margin-top:6px; }

    /* FIX: bounded chart containers prevent runaway vertical growth */
    .chartBox{ height: 280px; position: relative; }
    .chartBox.tall{ height: 330px; }
    .chartBox canvas{
      width: 100% !important;
      height: 100% !important;
      max-height: 100% !important;
      display:block;
    }

    .note{ margin-top:10px; font-size:12px; color:var(--muted); line-height:1.35; }
    .good{ color: var(--good); font-weight:900; }
    .bad{ color: var(--bad); font-weight:900; }
    .warn{ color: var(--warn); font-weight:900; }
    .first-available{
      margin-top:6px;
      font-size:12px;
      color: var(--muted);
      font-weight:800;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .filter-label{
      font-size:12px;
      color:var(--muted);
      font-weight:700;
    }
    .chart-section{
      margin-bottom:16px;
    }
    .chart-title{
      margin:0 0 8px;
      font-size:12px;
      color:var(--muted);
      font-weight:800;
      letter-spacing:.35px;
      text-transform:uppercase;
    }
    .vendor-list{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin:6px 0 12px;
    }
    .vendor-chip{
      font-size:11px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.18);
    }
    .history-table{
      width:100%;
      border-collapse:collapse;
      font-size:12px;
      margin-top:6px;
    }
    .history-table th,
    .history-table td{
      padding:6px 8px;
      border-bottom:1px solid rgba(255,255,255,.10);
      text-align:left;
    }
    .history-table th{
      color:var(--muted);
      font-weight:800;
      letter-spacing:.25px;
      text-transform:uppercase;
      font-size:11px;
    }
    .progress-wrap{
      margin-top:10px;
      display:none;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .progress-wrap.active{
      display:flex;
    }
    .progress-bar{
      position:relative;
      width:240px;
      max-width:100%;
      height:8px;
      border-radius:999px;
      background:rgba(255,255,255,.12);
      overflow:hidden;
    }
    .progress-bar span{
      position:absolute;
      inset:0;
      width:0%;
      border-radius:999px;
      background: linear-gradient(90deg, rgba(125,211,252,.85), rgba(196,181,253,.85));
      transition: width .2s ease;
    }
    .progress-meta{
      font-size:12px;
      color:var(--muted);
      font-weight:700;
    }
    .progress-meta b{
      color:var(--text);
    }
    .view-controls{
      margin: 12px 0 16px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <div class="title" id="pageTitle">Commodity Price Tracker</div>
        <div class="sub" id="status">Loaded. Run <b>setupOnce()</b> once in Apps Script, then use the buttons here.</div>
        <div class="progress-wrap" id="fetchProgress" aria-live="polite">
          <div class="progress-bar" aria-hidden="true"><span id="fetchProgressBar"></span></div>
          <div class="progress-meta" id="fetchProgressMeta">Fetching latest snapshot…</div>
        </div>
      </div>
      <div class="row">
        <button class="btn secondary" id="btnAdminToggle" aria-expanded="false">Admin Only - Click Here</button>
        <div class="admin-controls" id="adminControls" aria-hidden="true">
          <button class="btn" id="btnFetch">Fetch Latest</button>
          <button class="btn" id="btnRecord">Record Snapshot</button>
          <button class="btn" id="btnBasket">Refresh Basket</button>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Basket inflation</h3>
      <div class="kpis">
        <div class="kpi">
          <div class="label">BTC/USD</div>
          <div class="val" id="btcUsd">—</div>
        </div>
        <div class="kpi">
          <div class="label" id="basketIndexLabel">Basket Index (USD)</div>
          <div class="val" id="basketIndex">—</div>
        </div>
        <div class="kpi">
          <div class="label" id="inflLabel">Inflation vs baseline (USD)</div>
          <div class="val" id="infl">—</div>
        </div>
      </div>
      <div class="note">
        Inflation vs baseline compares the latest basket index in USD to your first recorded snapshot.
        A positive percentage means the latest basket costs more than the baseline and will be in red (inflation exists).
        A negative percentage means the latest basket costs less than the baseline and will be in green (deflation exists).
      </div>

      <div style="height:12px"></div>
      <div class="chartBox tall">
        <canvas id="basketChart"></canvas>
      </div>
    </div>

    <div class="row view-controls">
      <span class="filter-label">Commodity view</span>
      <div class="toggle-group" id="commodityToggle" role="group" aria-label="Commodity view toggle"></div>
    </div>

    <div class="grid">
      <div class="card" style="grid-column: 1 / -1;">
        <h3>Items (click one)</h3>
        <div class="items" id="items"></div>
        <div class="note" id="itemsNote"></div>
      </div>

      <div class="card" style="grid-column: 1 / -1;">
        <div class="row" style="justify-content:space-between;">
          <h3 style="margin:0;" id="itemTitle">Item history</h3>
          <div class="row">
            <span class="filter-label">Show</span>
            <select id="itemViewMode">
              <option value="selected">Selected only</option>
              <option value="all">All items</option>
            </select>
          </div>
        </div>

        <div style="height:12px"></div>
        <div id="itemCharts"></div>

        <div class="chart-title" style="margin-top:8px;">Vendors</div>
        <div id="itemVendors" class="vendor-list"></div>

        <div class="chart-title" style="margin-top:12px;">Historical records</div>
        <div style="overflow-x:auto;">
          <table class="history-table">
            <thead>
              <tr>
                <th>Date/time</th>
                <th id="historyCommodityLabel">Commodity</th>
                <th>USD</th>
                <th>Sats</th>
                <th>Gold (0.1g)</th>
                <th>Silver (g)</th>
                <th>MWh</th>
                <th>Vendor</th>
                <th>Provider</th>
                <th>Source URL</th>
                <th>Stale</th>
              </tr>
            </thead>
            <tbody id="itemHistoryRows"></tbody>
          </table>
        </div>

        <div class="note" id="itemNote"></div>
      </div>
    </div>
  </div>

<script>
  let cfg = null;
  let latest = null;
  let activeItemId = null;
  let itemViewMode = "selected";
  let commodityMode = "grocery";
  let referenceHistory = {
    basket: [],
    gold: [],
    silver: [],
    mwh: []
  };

  let itemCharts = [];
  let basketChart = null;
  let fetchProgressTimer = null;
  let fetchProgressHideTimer = null;
  let fetchProgressStart = null;
  let fetchProgressAvgMs = 12000;
  let viewProgressTimer = null;
  let viewProgressHideTimer = null;
  let viewProgressStart = null;

  const FETCH_AVG_KEY = "btc_dashboard_fetch_avg_ms";
  const FETCH_MIN_MS = 2000;
  const FETCH_MAX_MS = 60000;

  const COMMODITIES = [
    { id: "grocery", label: "Grocery Items", unitLabel: "grocery items", unitShort: "items", precision: 2 },
    { id: "sats", label: "Satoshis", unitLabel: "10,000 sats", unitShort: "x10k sats", precision: 2 },
    { id: "dollars", label: "Dollars", unitLabel: "$", unitShort: "$", precision: 2 },
    { id: "gold", label: "Gold", unitLabel: "0.1 gram gold", unitShort: "0.1g gold", precision: 4 },
    { id: "silver", label: "Silver", unitLabel: "1 gram silver", unitShort: "g silver", precision: 4 },
    { id: "mwh", label: "MWh", unitLabel: "1 MWh electricity", unitShort: "MWh", precision: 4 }
  ];

  const $ = (id) => document.getElementById(id);

  function setStatus(msg){ $("status").innerHTML = msg; }

  function fmtUsd(n){
    if (!isFinite(n)) return "—";
    return n.toLocaleString(undefined, { style: "currency", currency: "USD" });
  }
  function fmtSats(n){
    if (!isFinite(n)) return "—";
    return Math.round(n).toLocaleString() + " sats";
  }
  function fmtCommodity(n){
    if (!isFinite(n)) return "—";
    const cfg = getCommodityConfig();
    if (cfg.id === "dollars") return fmtUsd(n);
    if (cfg.id === "grocery") {
      const pct = n * 100;
      return pct.toLocaleString(undefined, { maximumFractionDigits: cfg.precision }) + "% of basket";
    }
    return n.toLocaleString(undefined, { maximumFractionDigits: cfg.precision }) + " " + cfg.unitShort;
  }
  function fmtCommodityForMode(n, mode){
    if (!isFinite(n)) return "—";
    const cfg = getCommodityConfigById(mode);
    if (cfg.id === "dollars") return fmtUsd(n);
    if (cfg.id === "grocery") {
      const pct = n * 100;
      return pct.toLocaleString(undefined, { maximumFractionDigits: cfg.precision }) + "% of basket";
    }
    return n.toLocaleString(undefined, { maximumFractionDigits: cfg.precision }) + " " + cfg.unitShort;
  }
  function fmtDate(d){
    if (!d) return "—";
    const dt = new Date(d);
    if (Number.isNaN(dt.getTime())) return "—";
    return dt.toLocaleDateString();
  }
  function fmtDateTime(d){
    if (!d) return "—";
    const dt = new Date(d);
    if (Number.isNaN(dt.getTime())) return "—";
    return dt.toLocaleString();
  }

  function priceCompareClass(current, original){
    if (!isFinite(current) || !isFinite(original)) return "";
    if (current > original) return "bad";
    if (current < original) return "good";
    return "";
  }

  function destroyChartSafe(ch){
    if (ch && typeof ch.destroy === "function") ch.destroy();
    return null;
  }

  function getAvgFetchMs(){
    const stored = Number(localStorage.getItem(FETCH_AVG_KEY));
    if (Number.isFinite(stored) && stored >= FETCH_MIN_MS) return stored;
    return fetchProgressAvgMs;
  }

  function updateAvgFetchMs(durationMs){
    if (!Number.isFinite(durationMs)) return;
    const clamped = Math.min(Math.max(durationMs, FETCH_MIN_MS), FETCH_MAX_MS);
    const prev = Number(localStorage.getItem(FETCH_AVG_KEY));
    const next = Number.isFinite(prev) ? Math.round(prev * 0.7 + clamped * 0.3) : Math.round(clamped);
    localStorage.setItem(FETCH_AVG_KEY, next);
  }

  function startFetchProgress(){
    const wrap = $("fetchProgress");
    const bar = $("fetchProgressBar");
    const meta = $("fetchProgressMeta");
    if (!wrap || !bar || !meta) return;

    if (fetchProgressTimer) clearInterval(fetchProgressTimer);
    if (fetchProgressHideTimer) clearTimeout(fetchProgressHideTimer);
    if (viewProgressTimer) clearInterval(viewProgressTimer);
    if (viewProgressHideTimer) clearTimeout(viewProgressHideTimer);

    fetchProgressStart = Date.now();
    fetchProgressAvgMs = getAvgFetchMs();

    wrap.classList.add("active");
    bar.style.width = "2%";

    const tick = () => {
      const elapsed = Date.now() - fetchProgressStart;
      const remaining = Math.max(fetchProgressAvgMs - elapsed, 0);
      const pct = Math.min((elapsed / fetchProgressAvgMs) * 100, 95);
      bar.style.width = `${pct.toFixed(1)}%`;
      if (remaining > 0) {
        meta.innerHTML = `Fetching latest snapshot… <b>~${Math.ceil(remaining / 1000)}s remaining</b>`;
      } else {
        meta.innerHTML = "Fetching latest snapshot… <b>finalizing</b>";
      }
    };

    tick();
    fetchProgressTimer = setInterval(tick, 250);
  }

  function stopFetchProgress(durationMs, wasSuccessful){
    const wrap = $("fetchProgress");
    const bar = $("fetchProgressBar");
    const meta = $("fetchProgressMeta");
    if (!wrap || !bar || !meta) return;

    if (fetchProgressTimer) clearInterval(fetchProgressTimer);
    fetchProgressTimer = null;

    if (wasSuccessful && Number.isFinite(durationMs)) {
      updateAvgFetchMs(durationMs);
      meta.innerHTML = `Latest snapshot loaded in <b>${(durationMs / 1000).toFixed(1)}s</b>`;
    } else if (wasSuccessful) {
      meta.innerHTML = "Latest snapshot loaded.";
    } else {
      meta.innerHTML = "Latest snapshot fetch stopped.";
    }
    bar.style.width = "100%";

    fetchProgressHideTimer = setTimeout(() => {
      wrap.classList.remove("active");
      bar.style.width = "0%";
    }, 1200);
  }

  function startViewProgress(message){
    const wrap = $("fetchProgress");
    const bar = $("fetchProgressBar");
    const meta = $("fetchProgressMeta");
    if (!wrap || !bar || !meta) return;

    if (fetchProgressTimer) clearInterval(fetchProgressTimer);
    if (fetchProgressHideTimer) clearTimeout(fetchProgressHideTimer);
    if (viewProgressTimer) clearInterval(viewProgressTimer);
    if (viewProgressHideTimer) clearTimeout(viewProgressHideTimer);

    wrap.classList.add("active");
    bar.style.width = "8%";
    meta.innerHTML = message || "Loading view…";
    viewProgressStart = Date.now();

    const tick = () => {
      const elapsed = Date.now() - viewProgressStart;
      const pct = Math.min(8 + (elapsed / 1200) * 80, 92);
      bar.style.width = `${pct.toFixed(1)}%`;
    };

    tick();
    viewProgressTimer = setInterval(tick, 120);
  }

  function stopViewProgress(message){
    const wrap = $("fetchProgress");
    const bar = $("fetchProgressBar");
    const meta = $("fetchProgressMeta");
    if (!wrap || !bar || !meta) return;

    if (viewProgressTimer) clearInterval(viewProgressTimer);
    viewProgressTimer = null;
    if (viewProgressHideTimer) clearTimeout(viewProgressHideTimer);

    meta.innerHTML = message || "View loaded.";
    bar.style.width = "100%";
    viewProgressHideTimer = setTimeout(() => {
      wrap.classList.remove("active");
      bar.style.width = "0%";
    }, 800);
  }

  function clearItemCharts(){
    itemCharts.forEach(ch => destroyChartSafe(ch));
    itemCharts = [];
    const root = $("itemCharts");
    if (root) root.innerHTML = "";
  }

  function escapeHtml(s){
    return String(s || "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function isValidVendor(source){
    const cleaned = String(source || "").trim();
    if (!cleaned) return false;
    if (cleaned === "last_known" || cleaned === "cache") return false;
    if (/^error:/i.test(cleaned)) return false;
    return true;
  }

  function hasSourceUrl(row){
    return Boolean(row && String(row.source_url || "").trim());
  }

  function hexToRgba(hex, alpha){
    const clean = String(hex || "").replace("#", "");
    if (clean.length !== 6) return `rgba(255,255,255,${alpha})`;
    const num = parseInt(clean, 16);
    const r = (num >> 16) & 255;
    const g = (num >> 8) & 255;
    const b = num & 255;
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }

  function getSourceUrl(row){
    if (row && row.source_url) return row.source_url;
    return "";
  }

  function normalizeKey(s){
    return String(s || "").toLowerCase().replace(/[^a-z0-9]+/g, "");
  }

  function getCommodityConfig(){
    return COMMODITIES.find(x => x.id === commodityMode) || COMMODITIES[0];
  }
  function getCommodityConfigById(mode){
    return COMMODITIES.find(x => x.id === mode) || COMMODITIES[0];
  }

  function updateCommodityTitle(){
    const cfg = getCommodityConfig();
    const title = `Commodity Price Tracker — ${cfg.label}`;
    const titleEl = $("pageTitle");
    if (titleEl) titleEl.textContent = title;
    document.title = title;
    $("historyCommodityLabel").textContent = `${cfg.label} (${cfg.unitLabel})`;
  }

  function renderCommodityToggle(){
    const root = $("commodityToggle");
    if (!root) return;
    root.innerHTML = "";
    COMMODITIES.forEach(opt => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "toggle-btn" + (commodityMode === opt.id ? " active" : "");
      btn.textContent = opt.label;
      btn.setAttribute("aria-pressed", commodityMode === opt.id ? "true" : "false");
      btn.onclick = () => setCommodityMode(opt.id);
      root.appendChild(btn);
    });
  }

  async function setCommodityMode(mode){
    if (commodityMode === mode) return;
    startViewProgress("Loading view…");
    commodityMode = mode;
    renderCommodityToggle();
    updateCommodityTitle();
    await ensureCommodityReferences();
    renderItems();
    await renderItemHistory();
    await renderBasket();
    stopViewProgress("View loaded.");
  }

  function getLatestCommodityUsd(type){
    if (!latest?.items?.length) return NaN;
    const match = latest.items.find(item => normalizeKey(item.name) === type);
    return match?.usd;
  }

  function findReferenceValue(history, ts, key){
    if (!history || !history.length) return null;
    if (!ts) return history[history.length - 1][key];
    const target = new Date(ts).getTime();
    if (!Number.isFinite(target)) return history[history.length - 1][key];
    let best = null;
    for (let i = 0; i < history.length; i++) {
      const t = new Date(history[i].ts).getTime();
      if (t <= target) best = history[i];
      if (t > target) break;
    }
    return (best || history[0])[key];
  }

  function getReferenceUsd(type, ts){
    if (type === "gold") {
      const value = findReferenceValue(referenceHistory.gold, ts, "usd");
      return isFinite(value) ? value : getLatestCommodityUsd("gold");
    }
    if (type === "silver") {
      const value = findReferenceValue(referenceHistory.silver, ts, "usd");
      return isFinite(value) ? value : getLatestCommodityUsd("silver");
    }
    if (type === "mwh") {
      const value = findReferenceValue(referenceHistory.mwh, ts, "usd");
      return isFinite(value) ? value : getLatestCommodityUsd("mwh");
    }
    if (type === "grocery") {
      const value = findReferenceValue(referenceHistory.basket, ts, "basketIndexUsd");
      return isFinite(value) ? value : null;
    }
    return null;
  }

  function getCommodityValue(usd, sats, ts){
    return getCommodityValueForMode(commodityMode, usd, sats, ts);
  }

  function getCommodityValueForMode(mode, usd, sats, ts){
    if (!isFinite(usd) && !isFinite(sats)) return NaN;
    switch (mode) {
      case "sats":
        return isFinite(sats) ? (sats / 10000) : NaN;
      case "dollars":
        return isFinite(usd) ? usd : NaN;
      case "gold": {
        const ref = getReferenceUsd("gold", ts);
        return isFinite(usd) && isFinite(ref) && ref > 0 ? (usd / ref) : NaN;
      }
      case "silver": {
        const ref = getReferenceUsd("silver", ts);
        return isFinite(usd) && isFinite(ref) && ref > 0 ? (usd / ref) : NaN;
      }
      case "mwh": {
        const ref = getReferenceUsd("mwh", ts);
        return isFinite(usd) && isFinite(ref) && ref > 0 ? (usd / ref) : NaN;
      }
      case "grocery":
      default: {
        const ref = getReferenceUsd("grocery", ts);
        return isFinite(usd) && isFinite(ref) && ref > 0 ? (usd / ref) : NaN;
      }
    }
  }

  function getCommodityDescriptionByName(name){
    const normalized = normalizeKey(name);
    const match = latest?.items?.find(item => normalizeKey(item.name) === normalized);
    return match?.item_description || "";
  }

  async function loadCommodityHistories(){
    const descriptions = [];
    const goldDescription = getCommodityDescriptionByName("gold");
    const silverDescription = getCommodityDescriptionByName("silver");
    const mwhDescription = getCommodityDescriptionByName("mwh");
    if (goldDescription) descriptions.push(goldDescription);
    if (silverDescription) descriptions.push(silverDescription);
    if (mwhDescription) descriptions.push(mwhDescription);

    if (!descriptions.length) {
      referenceHistory.gold = [];
      referenceHistory.silver = [];
      referenceHistory.mwh = [];
      return;
    }

    referenceHistory.gold = [];
    referenceHistory.silver = [];
    referenceHistory.mwh = [];
    const histories = await new Promise((resolve, reject) => {
      google.script.run.withSuccessHandler(resolve).withFailureHandler(reject).getAllItemHistories(descriptions);
    });

    histories.forEach(entry => {
      const key = normalizeKey(entry.description);
      if (goldDescription && key === normalizeKey(goldDescription)) {
        referenceHistory.gold = entry.history || [];
      }
      if (silverDescription && key === normalizeKey(silverDescription)) {
        referenceHistory.silver = entry.history || [];
      }
      if (mwhDescription && key === normalizeKey(mwhDescription)) {
        referenceHistory.mwh = entry.history || [];
      }
    });
  }

  async function ensureCommodityReferences(includeMetals = false){
    if (!referenceHistory.basket.length) {
      referenceHistory.basket = await new Promise((resolve, reject) => {
        google.script.run.withSuccessHandler(resolve).withFailureHandler(reject).getBasketHistory();
      });
    }
    if (includeMetals || commodityMode === "gold" || commodityMode === "silver" || commodityMode === "mwh") {
      if (!referenceHistory.gold.length && !referenceHistory.silver.length && !referenceHistory.mwh.length) {
        await loadCommodityHistories();
      }
    }
  }

  function renderItems(){
    const root = $("items");
    root.innerHTML = "";

    cfg.items.forEach(it => {
      const row = latest?.items?.find(x => x.id === it.id);
      const isCashTen = it.id === "cash10";
      const latestTs = row?.ts || latest?.ts;
      const cashUsd = 10;
      const cashSats = isFinite(latest?.btcUsd) ? (cashUsd / latest.btcUsd) * 100000000 : NaN;
      const usd = isCashTen ? cashUsd : row?.usd;
      const sats = isCashTen ? cashSats : row?.sats;
      const stale = isCashTen ? false : Boolean(row?.is_stale);
      const source = row?.price_source || "";
      const vendor = row?.price_vendor || "";
      const description = row?.item_description || it.name;
      const sourceUrl = getSourceUrl(row);
      const first = row?.first_available;
      const firstDate = fmtDate(first?.ts);
      const firstCommodity = first ? fmtCommodity(getCommodityValue(first.usd, first.sats, first.ts)) : "—";
      const firstCommodityValue = first ? getCommodityValue(first.usd, first.sats, first.ts) : NaN;
      const firstUsd = first?.usd != null ? fmtUsd(first.usd) : "—";
      const firstSats = first?.sats != null ? fmtSats(first.sats) : "—";
      const firstGoldValue = first ? getCommodityValueForMode("gold", first.usd, first.sats, first.ts) : NaN;
      const firstSilverValue = first ? getCommodityValueForMode("silver", first.usd, first.sats, first.ts) : NaN;
      const firstMwhValue = first ? getCommodityValueForMode("mwh", first.usd, first.sats, first.ts) : NaN;
      const firstGold = first ? fmtCommodityForMode(firstGoldValue, "gold") : "—";
      const firstSilver = first ? fmtCommodityForMode(firstSilverValue, "silver") : "—";
      const firstMwh = first ? fmtCommodityForMode(firstMwhValue, "mwh") : "—";
      const vendorCount = Number.isFinite(row?.vendor_count) ? row.vendor_count : 0;
      const usdClass = priceCompareClass(usd, first?.usd);
      const satsClass = priceCompareClass(sats, first?.sats);
      const isUnverified = !stale && !hasSourceUrl(row) && !isCashTen;
      const latestTsLabel = latestTs ? fmtDateTime(latestTs) : "—";
      const commodityValue = getCommodityValue(usd, sats, latestTs);
      const commodityClass = priceCompareClass(commodityValue, firstCommodityValue);
      const latestGoldValue = getCommodityValueForMode("gold", usd, sats, latestTs);
      const latestSilverValue = getCommodityValueForMode("silver", usd, sats, latestTs);
      const latestMwhValue = getCommodityValueForMode("mwh", usd, sats, latestTs);
      const latestGoldClass = commodityMode === "gold" ? priceCompareClass(latestGoldValue, firstGoldValue) : "";
      const latestSilverClass = commodityMode === "silver" ? priceCompareClass(latestSilverValue, firstSilverValue) : "";
      const latestMwhClass = commodityMode === "mwh" ? priceCompareClass(latestMwhValue, firstMwhValue) : "";
      const latestGold = fmtCommodityForMode(latestGoldValue, "gold");
      const latestSilver = fmtCommodityForMode(latestSilverValue, "silver");
      const latestMwh = fmtCommodityForMode(latestMwhValue, "mwh");

      const div = document.createElement("div");
      div.className = "item" + (it.id === activeItemId ? " active" : "");
      div.onclick = () => selectItem(it.id);

      const badge = stale ? `<span class="badge stale">STALE</span>` :
                   isUnverified ? `<span class="badge stale">UNVERIFIED</span>` :
                   vendor ? `<span class="badge">${escapeHtml(vendor)}</span>` :
                   source ? `<span class="badge">${escapeHtml(source)}</span>` : "";

      div.innerHTML = `
        <div class="name">${escapeHtml(description)} ${badge}</div>
        <div class="meta">
          <span>
            Latest: <span class="${commodityClass}">${fmtCommodity(commodityValue)}</span> •
            <span class="${usdClass}">${usd != null ? fmtUsd(usd) : "—"}</span> /
            <span class="${satsClass}">${sats != null ? fmtSats(sats) : "—"}</span> /
            <span class="${latestGoldClass}">Gold: ${latestGold}</span> /
            <span class="${latestSilverClass}">Silver: ${latestSilver}</span> /
            <span class="${latestMwhClass}">MWh: ${latestMwh}</span>
            <span>as of ${escapeHtml(latestTsLabel)}</span>
          </span>
        </div>
        <div class="first-available">
          <span>Earliest: ${firstCommodity} • ${firstUsd} / ${firstSats} / ${firstGold} / ${firstSilver} / ${firstMwh} on ${firstDate}</span>
          <span>
            Vendors seen: ${vendorCount}
            ${sourceUrl ? `• <a class="source-link" href="${escapeHtml(sourceUrl)}" target="_blank" rel="noopener noreferrer">Source URL</a>` : "• No source URL"}
          </span>
        </div>
      `;
      root.appendChild(div);
    });

    const itemsNote = $("itemsNote");
    if (itemsNote) {
      if (commodityMode === "grocery") {
        itemsNote.textContent = "Grocery items view shows each item's USD price divided by the latest basket baseline (average of all items). Values are displayed as percent of the baseline basket (e.g., 17% of basket).";
      } else {
        itemsNote.textContent = "";
      }
    }
  }

  async function selectItem(itemId){
    activeItemId = itemId;
    renderItems();
    await renderItemHistoryWithProgress();
  }

  async function loadConfig(){
    cfg = await new Promise((resolve, reject) => {
      google.script.run.withSuccessHandler(resolve).withFailureHandler(reject).getConfig();
    });
  }

  async function loadLatestFromSheet(){
    setStatus("Loading latest snapshot from sheet...");

    try{
      latest = await new Promise((resolve, reject) => {
        google.script.run.withSuccessHandler(resolve).withFailureHandler(reject).getLatestSnapshotFromSheet();
      });

      if (latest?.btcUsd != null) {
        $("btcUsd").textContent = fmtUsd(latest.btcUsd);
      } else {
        $("btcUsd").textContent = "—";
      }

      if (!activeItemId && cfg.items.length) activeItemId = cfg.items[0].id;
      renderCommodityToggle();
      updateCommodityTitle();
      await ensureCommodityReferences();
      renderItems();
      await renderItemHistoryWithProgress();
      await renderBasket();

      if (latest?.ts) {
        setStatus("Loaded latest snapshot from sheet: <b>" + new Date(latest.ts).toLocaleString() + "</b>");
      } else {
        setStatus("Loaded config. No snapshot rows found in the sheet yet.");
      }
    } catch (err) {
      setStatus("<b style='color:#fb7185'>Sheet load failed:</b> " + escapeHtml(String(err)));
    }
  }

  async function fetchLatest(){
    setStatus("Fetching latest snapshot (cached 10 minutes)...");
    $("btnFetch").disabled = true;
    startFetchProgress();
    const fetchStart = Date.now();
    let fetchSuccess = false;

    try{
      latest = await new Promise((resolve, reject) => {
        google.script.run.withSuccessHandler(resolve).withFailureHandler(reject).fetchLatestSnapshot();
      });

      $("btcUsd").textContent = fmtUsd(latest.btcUsd);

      if (!activeItemId && cfg.items.length) activeItemId = cfg.items[0].id;
      renderCommodityToggle();
      updateCommodityTitle();
      await ensureCommodityReferences();
      renderItems();

      await renderItemHistoryWithProgress();
      await renderBasket();

      const anyStale = (latest.items || []).some(x => x.is_stale);
      setStatus(
        "Latest fetched: <b>" + new Date(latest.ts).toLocaleString() + "</b>" +
        (anyStale ? " — <span class='warn'>some prices are stale (fallback)</span>" : "")
      );
      fetchSuccess = true;

    } catch (err) {
      setStatus("<b style='color:#fb7185'>Fetch failed:</b> " + escapeHtml(String(err)));
    } finally {
      $("btnFetch").disabled = false;
      stopFetchProgress(Date.now() - fetchStart, fetchSuccess);
    }
  }

  async function recordSnapshot(){
    setStatus("Recording snapshot to permanent history...");
    $("btnRecord").disabled = true;

    try{
      const res = await new Promise((resolve, reject) => {
        google.script.run.withSuccessHandler(resolve).withFailureHandler(reject).recordSnapshot();
      });

      setStatus("Recorded <b>" + res.rowsAppended + "</b> rows at <b>" + new Date(res.recordedAt).toLocaleString() + "</b>");
      await renderBasket();
      await renderItemHistoryWithProgress();

    } catch (err) {
      setStatus("<b style='color:#fb7185'>Record failed:</b> " + escapeHtml(String(err)));
    } finally {
      $("btnRecord").disabled = false;
    }
  }

  function createChartSection(titleText, showTitle){
    const section = document.createElement("div");
    section.className = "chart-section";
    if (showTitle) {
      const title = document.createElement("div");
      title.className = "chart-title";
      title.textContent = titleText;
      section.appendChild(title);
    }
    const box = document.createElement("div");
    box.className = "chartBox";
    const canvas = document.createElement("canvas");
    box.appendChild(canvas);
    section.appendChild(box);
    $("itemCharts").appendChild(section);
    return canvas;
  }

  function buildItemChart(canvas, hist){
    const labels = hist.map(p => new Date(p.ts).toLocaleString());
    const commoditySeries = hist.map(p => getCommodityValue(Number(p.usd), Number(p.sats), p.ts));
    const cfg = getCommodityConfig();

    const chart = new Chart(canvas.getContext("2d"), {
      type: "line",
      data: {
        labels,
        datasets: [{
          label: `${cfg.label} (${cfg.unitLabel})`,
          data: commoditySeries,
          borderColor: "#7dd3fc",
          backgroundColor: "rgba(125,211,252,0.15)",
          pointBackgroundColor: "#7dd3fc",
          pointBorderColor: "#7dd3fc",
          borderWidth: 2,
          tension: 0.25,
          pointRadius: 2
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        plugins: { legend: { display: true } },
        scales: {
          x: { ticks: { maxTicksLimit: 6 } },
          y: {
            title: {
              display: true,
              text: cfg.unitLabel
            }
          }
        }
      }
    });
    itemCharts.push(chart);
  }

  function buildAllItemsChart(allHistories){
    const palette = [
      "#7dd3fc", "#c4b5fd", "#34d399", "#fbbf24", "#fb7185",
      "#a5b4fc", "#f472b6", "#93c5fd", "#86efac", "#fca5a5"
    ];

    const timestamps = new Set();
    allHistories.forEach(item => {
      (item.history || []).forEach(point => timestamps.add(point.ts));
    });

    const sortedTs = Array.from(timestamps).sort((a, b) => new Date(a) - new Date(b));
    const labels = sortedTs.map(ts => new Date(ts).toLocaleString());

    const cfg = getCommodityConfig();
    const datasets = allHistories.map((item, idx) => {
      const color = palette[idx % palette.length];
      const map = new Map((item.history || []).map(point => [
        point.ts,
        getCommodityValue(Number(point.usd), Number(point.sats), point.ts)
      ]));
      return {
        label: item.description,
        data: sortedTs.map(ts => map.has(ts) ? map.get(ts) : null),
        borderColor: color,
        backgroundColor: hexToRgba(color, 0.12),
        pointBackgroundColor: color,
        pointBorderColor: color,
        borderWidth: 2,
        tension: 0.25,
        pointRadius: 2,
        spanGaps: true
      };
    });

    const canvas = createChartSection("All item history", true);
    const chart = new Chart(canvas.getContext("2d"), {
      type: "line",
      data: { labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        plugins: { legend: { display: true } },
        scales: {
          x: { ticks: { maxTicksLimit: 6 } },
          y: { title: { display: true, text: cfg.unitLabel } }
        }
      }
    });
    itemCharts.push(chart);
  }

  async function renderItemHistory(){
    if (!activeItemId) return;

    itemViewMode = $("itemViewMode")?.value || "selected";
    clearItemCharts();
    await ensureCommodityReferences(true);

    if (itemViewMode === "all") {
      const selectedItem = cfg.items.find(x => x.id === activeItemId);
      const orderedItems = [
        selectedItem,
        ...cfg.items.filter(x => x.id !== activeItemId)
      ].filter(Boolean);

      const descriptions = orderedItems.map(item => {
        const latestRow = latest?.items?.find(x => x.id === item.id);
        return latestRow?.item_description || item?.name || "";
      }).filter(Boolean);

      const allHistories = await new Promise((resolve, reject) => {
        google.script.run.withSuccessHandler(resolve).withFailureHandler(reject).getAllItemHistories(descriptions);
      });

      const historyMap = new Map(allHistories.map(item => [item.description, item.history || []]));

      let staleCount = 0;
      descriptions.forEach(description => {
        const hist = historyMap.get(description) || [];
        staleCount += hist.filter(x => x.is_stale).length;
        const canvas = createChartSection(description, true);
        buildItemChart(canvas, hist);
      });

      buildAllItemsChart(allHistories);

      $("itemTitle").textContent = "All item history";
      $("itemNote").innerHTML = staleCount
        ? `<span class='warn'>${staleCount} stale points</span>`
        : "Selected item first, then all other items, with the combined chart at the bottom.";
      $("itemVendors").innerHTML = "<span class='badge'>Select a single item to see vendors</span>";
      $("itemHistoryRows").innerHTML = "<tr><td colspan='11'>Select a single item to see detailed records.</td></tr>";
      return;
    }

    const item = cfg.items.find(x => x.id === activeItemId);
    const latestRow = latest?.items?.find(x => x.id === activeItemId);
    const description = latestRow?.item_description || item?.name || "Item history";

    const hist = await new Promise((resolve, reject) => {
      google.script.run.withSuccessHandler(resolve).withFailureHandler(reject).getItemHistory(description);
    });

    const staleCount = hist.filter(x => x.is_stale).length;

    $("itemTitle").textContent = description;
    const unverifiedCount = hist.filter(point => !point.is_stale && !hasSourceUrl(point)).length;
    const notes = [];
    if (staleCount) notes.push("<span class='warn'>" + staleCount + " stale points</span>");
    if (unverifiedCount) notes.push("<span class='warn'>" + unverifiedCount + " unverified (no source URL)</span>");
    notes.push("Cache/stale fallback is only used when enabled; otherwise missing providers show as unverified with no URL.");
    $("itemNote").innerHTML = notes.join(" • ");

    const canvas = createChartSection("", false);
    buildItemChart(canvas, hist);

    const vendorSet = new Set();
    hist.forEach(point => {
      if (isValidVendor(point.price_vendor)) {
        vendorSet.add(point.price_vendor);
      }
    });
    const vendors = Array.from(vendorSet).sort();
    const vendorRoot = $("itemVendors");
    if (vendors.length) {
      vendorRoot.innerHTML = vendors
        .map(vendor => `<span class="vendor-chip">${escapeHtml(vendor)}</span>`)
        .join("");
    } else {
      vendorRoot.innerHTML = "<span class='badge'>No vendor data yet</span>";
    }

    const rowsRoot = $("itemHistoryRows");
    if (!hist.length) {
      rowsRoot.innerHTML = "<tr><td colspan='11'>No history rows yet.</td></tr>";
    } else {
      const orderedHistory = [...hist].sort((a, b) => new Date(b.ts) - new Date(a.ts));
      rowsRoot.innerHTML = orderedHistory.map(point => {
        const vendorLabel = isValidVendor(point.price_vendor) ? point.price_vendor : "—";
        const providerLabel = point.price_source ? point.price_source : "—";
        const sourceUrl = hasSourceUrl(point) ? point.source_url : "";
        const commodityValue = getCommodityValue(Number(point.usd), Number(point.sats), point.ts);
        const goldValue = getCommodityValueForMode("gold", Number(point.usd), Number(point.sats), point.ts);
        const silverValue = getCommodityValueForMode("silver", Number(point.usd), Number(point.sats), point.ts);
        const mwhValue = getCommodityValueForMode("mwh", Number(point.usd), Number(point.sats), point.ts);
        return `
          <tr>
            <td>${escapeHtml(fmtDateTime(point.ts))}</td>
            <td>${escapeHtml(fmtCommodity(commodityValue))}</td>
            <td>${escapeHtml(fmtUsd(point.usd))}</td>
            <td>${escapeHtml(fmtSats(point.sats))}</td>
            <td>${escapeHtml(fmtCommodityForMode(goldValue, "gold"))}</td>
            <td>${escapeHtml(fmtCommodityForMode(silverValue, "silver"))}</td>
            <td>${escapeHtml(fmtCommodityForMode(mwhValue, "mwh"))}</td>
            <td>${escapeHtml(vendorLabel)}</td>
            <td>${escapeHtml(providerLabel)}</td>
            <td>${sourceUrl ? `<a class="source-link" href="${escapeHtml(sourceUrl)}" target="_blank" rel="noopener noreferrer">Source</a>` : "—"}</td>
            <td>${point.is_stale ? "Yes" : "No"}</td>
          </tr>
        `;
      }).join("");
    }
  }

  async function renderItemHistoryWithProgress(){
    startViewProgress("Loading item view…");
    try {
      await renderItemHistory();
    } finally {
      stopViewProgress("Item view loaded.");
    }
  }

  async function renderBasket(){
    const hist = await new Promise((resolve, reject) => {
      google.script.run.withSuccessHandler(resolve).withFailureHandler(reject).getBasketHistory();
    });

    referenceHistory.basket = hist;

    await ensureCommodityReferences(true);

    const labels = hist.map(point => new Date(point.ts).toLocaleString());
    const usdSeries = hist.map(point => Number(point.basketIndexUsd));
    const first = usdSeries.find(val => isFinite(val));
    const last = [...usdSeries].reverse().find(val => isFinite(val));
    const inflationPct = (isFinite(first) && isFinite(last) && first !== 0)
      ? ((last / first) - 1) * 100
      : 0;
    const inflCls = inflationPct >= 0 ? "bad" : "good";
    $("infl").innerHTML = `<span class="${inflCls}">${inflationPct.toFixed(2)}%</span>`;
    $("basketIndex").textContent = fmtUsd(last);

    const commodityColors = {
      grocery: "#fbbf24",
      sats: "#a5b4fc",
      dollars: "#7dd3fc",
      gold: "#f59e0b",
      silver: "#94a3b8",
      mwh: "#22d3ee"
    };
    const datasets = COMMODITIES.map(mode => {
      const color = commodityColors[mode.id] || "#7dd3fc";
      const series = hist.map(point => {
        const usd = Number(point.basketIndexUsd);
        const sats = Number(point.basketIndexSats);
        return getCommodityValueForMode(mode.id, usd, sats, point.ts);
      });
      return {
        label: `Basket (${mode.label})`,
        data: series,
        borderColor: color,
        backgroundColor: hexToRgba(color, 0.18),
        pointBackgroundColor: color,
        pointBorderColor: color,
        borderWidth: 2,
        tension: 0.25,
        pointRadius: 2,
        spanGaps: true
      };
    });

    basketChart = destroyChartSafe(basketChart);

    const ctx = $("basketChart").getContext("2d");
    basketChart = new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        plugins: { legend: { display: true } },
        scales: {
          x: {
            title: { display: true, text: "Time" },
            ticks: { maxTicksLimit: 6 }
          },
          y: {
            title: { display: true, text: "Price" },
            beginAtZero: false
          }
        }
      }
    });
  }

  function toggleAdminControls(){
    const controls = $("adminControls");
    const toggle = $("btnAdminToggle");
    if (!controls || !toggle) return;
    const isVisible = controls.classList.toggle("is-visible");
    controls.setAttribute("aria-hidden", String(!isVisible));
    toggle.setAttribute("aria-expanded", String(isVisible));
    toggle.textContent = isVisible ? "Admin Only - Hide Buttons" : "Admin Only - Click Here";
  }

  $("btnFetch").addEventListener("click", fetchLatest);
  $("btnRecord").addEventListener("click", recordSnapshot);
  $("btnBasket").addEventListener("click", renderBasket);
  $("itemViewMode").addEventListener("change", renderItemHistoryWithProgress);
  $("btnAdminToggle").addEventListener("click", toggleAdminControls);

  (async () => {
    try {
      await loadConfig();
      await loadLatestFromSheet();
    } catch (err) {
      setStatus("<b style='color:#fb7185'>Init failed:</b> " + escapeHtml(String(err)));
    }
  })();
</script>
</body>
</html>
